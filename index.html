<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        table, th, td {
            border: 1px solid black;
            border-collapse: collapse;
        }

        th, td {
            padding: 5px;
            text-align: left;
        }
    </style>
</head>
<body>

<div id="app"></div>


<script type="module" lang="javascript">
    import {opcodes} from "./opcodes.js"


    const removeAt = array => index => array.splice(index, 1);
    const removeItem = array => item => {
        const i = array.indexOf(item);
        if (i >= 0) {
            return removeAt(array)(i);
        }
        return [];
    };


    const Observable = value => {
        const listeners = [];
        const removeListener = listener => removeItem(listeners)(listener);
        const noop = () => undefined;
        return {
            onChange: callback => {
                listeners.push(callback);
                callback(value, value, noop);
            },
            getValue: () => value,
            setValue: newValue => {
                if (value === newValue) return;
                const oldValue = value;
                value = newValue;
                const safeIterate = [...listeners]; // shallow copy as we might change the listeners array while iterating
                safeIterate.forEach(listener => {
                    if (value === newValue) { // pre-ordered listeners might have changed this and thus the callback no longer applies
                        listener(value, oldValue, () => removeListener(listener));
                    }
                });
            }
        };
    }


    const OpCodeController = () => {


        /**
         * Creates a lookup array from the given opcodes and prefix.
         * @param opcodes
         * @param prefix
         * @returns {(*&{prefix: *, hasPrefix: boolean, number: number, bin: string, hex: *})[]}
         */
        const createLookup = (opcodes, prefix) => Object
            .keys(opcodes)
            .map(key => {
                const num = parseInt(key, 16);
                const bin = num.toString(2).padStart(8, "0")
                return {
                    ...{
                        prefix,
                        hasPrefix: prefix !== '',
                        number: num,
                        bin,
                        hex: key
                    },
                    ...opcodes[key],
                }
            })


        const lookup = createLookup(opcodes.unprefixed, '').concat(createLookup(opcodes.cbprefixed, '0xCB'));

        const $opcodes = Observable(lookup);

        /**
         * Filters the opcode list based on the provided filter.
         * @param filter @type {{prefix: boolean, bitLookup: string}}
         */
        const filterOpcode = (filter) => {
            const value = filter.bitLookup
                .replaceAll(' ', '')
                .trim()
                .padEnd(8, 'n');

            const filtered = lookup
                .filter(n => n.hasPrefix === filter.prefix)
                .filter(n => {

                    let i = 0;

                    while (i < value.length) {
                        if ((value[i] === '0' || value[i] === '1') && value[i] !== n.bin[i]) {
                            return false;
                        }
                        i++;
                    }
                    return true;
                })
                .map(n => {
                    return {
                        ...n,
                        binColors: value.split('').map((b) => {

                            return (b === '0' ||  b === '1')
                                ? '#cfcfcf' : `#${(b.charCodeAt() * 343).toString(16).padStart(6, '0')}` ;
                        })
                    };
                });

            $opcodes.setValue(filtered);
        }

        const $filters = Observable({
            prefix: false,
            bitLookup: '',
        });


        $filters.onChange( filterOpcode )

        const setFilter = (newFilter) => {
            $filters.setValue({
                ...$filters.getValue(),
                ...newFilter
            });
        }

        return {
            onOpcodeChange: $opcodes.onChange,
            filterOpcode,
            setFilter
        }
    }


    const projectBitLookup = (controller ) => {
        const inp = document.createElement("input");
        inp.style = 'width: 90%; margin: 5px';

        inp.addEventListener("input", () =>
            controller.setFilter({
                bitLookup: inp.value
            }))

        const head = document.createElement("th")
        head.appendChild(inp)
        head.colSpan = 8;
        return head;
    }

    const projectPrefixCheckbox = (controller, colspan = 1) => {
        const inp = document.createElement("input");
        inp.type = "checkbox";

        inp.addEventListener("input", (e) =>

            controller.setFilter({
                prefix: e.target.checked
            }));

        const head = document.createElement("th")
        head.appendChild(inp)
        head.colSpan = colspan;
        return head;
    }

    const tableHead = (value, colspan = 1,) => {
        const th = document.createElement("th");
        th.innerHTML = value;

        th.colSpan = colspan;
        return th
    }

    const projectOpcodeTable = (controller) => {

        const tableHeader = document.createElement("thead");

        tableHeader.appendChild(tableHead("Num"));
        tableHeader.appendChild(projectPrefixCheckbox(controller))
        tableHeader.appendChild(tableHead("Hex"));


        tableHeader.appendChild(projectBitLookup(controller))

        tableHeader.appendChild(tableHead("mnemonic"));
        tableHeader.appendChild(tableHead("o1"));
        tableHeader.appendChild(tableHead("o2"));
        tableHeader.appendChild(tableHead("o3"));

        tableHeader.appendChild(tableHead("bytes"));
        tableHeader.appendChild(tableHead("Z"));
        tableHeader.appendChild(tableHead("N"));
        tableHeader.appendChild(tableHead("H"));
        tableHeader.appendChild(tableHead("C"));
        tableHeader.appendChild(tableHead("decoder"));


        const tableDistrict = (value, backgroundColor = "") => {
            const td = document.createElement("td");
            td.textContent = value;

            if (backgroundColor !== "")
                td.style = `background-color: ${backgroundColor}`;

            return td;
        }


        const tableBody = document.createElement("tbody")

        controller.onOpcodeChange(codes => {
            tableBody.innerHTML = "";
            for (const code of codes) {
                const row = document.createElement("tr")

                row.appendChild(tableDistrict(code.number));
                row.appendChild(tableDistrict(code.prefix));
                row.appendChild(tableDistrict(code.hex));

                for (let i = 0; i < 8; i++) {

                    row.appendChild(tableDistrict(code.bin[i], code.binColors[i]));
                }

                row.appendChild(tableDistrict(code.mnemonic));

                for (let idx in code.operands) {
                    row.appendChild(tableDistrict(code.operands[idx].name));
                }

                for (let idx = code.operands.length; idx < 3; idx++) {
                    row.appendChild(tableDistrict(""));
                }

                row.appendChild(tableDistrict(code.bytes));

                // Fill empty operand cells
                for (let f in code.flags) {
                    row.appendChild(tableDistrict(code.flags[f]));
                }


                row.appendChild(tableDistrict(`${code.hex} -> decode("${code.mnemonic} ${code.operands.map(o => o.name).join(", ")}", ${code.bytes - 1})`))
                tableBody.appendChild(row);
            }
        });


        const table = document.createElement("table")
        table.appendChild(tableHeader);
        table.appendChild(tableBody)
        return table;
    }


    const app = document.getElementById("app")
    app.appendChild(projectOpcodeTable(OpCodeController()))

</script>
</body>
</html>